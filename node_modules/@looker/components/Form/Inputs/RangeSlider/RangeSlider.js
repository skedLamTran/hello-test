function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import "core-js/modules/es.array.sort.js";
import "core-js/modules/es.array.map.js";
import "core-js/modules/es.object.assign.js";
import "core-js/modules/es.array.concat.js";
import "core-js/modules/es.object.define-property.js";
import "core-js/modules/es.array.is-array.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.from.js";
import { useTranslation } from 'react-i18next';
import React, { forwardRef, useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { reset, space, typography } from '@looker/design-tokens';
import styled from 'styled-components';
import sortBy from 'lodash/sortBy';
import indexOf from 'lodash/indexOf';
import startsWith from 'lodash/startsWith';
import partial from 'lodash/partial';
import map from 'lodash/map';
import isEqual from 'lodash/isEqual';
import { useMeasuredElement, useMouseDragPosition, useReadOnlyWarn, usePreviousValue } from '../../../utils';
import { getPrecision, precisionRound } from './precisionUtils';

var sort = function sort(arr) {
  return arr.sort(function (a, b) {
    return a - b;
  });
};

var findClosestIndex = function findClosestIndex(value, newPoint) {
  var closestIndex = sortBy(value.map(function (p, i) {
    return {
      distance: Math.abs(p - newPoint),
      index: i
    };
  }), 'distance')[0].index;
  return closestIndex;
};

var createNewValue = function createNewValue(value, newPoint, focusedIndex) {
  var indexToReplace = focusedIndex === undefined ? findClosestIndex(value, newPoint) : focusedIndex;
  var newValue = Object.assign([], value, _defineProperty({}, indexToReplace, newPoint));
  return sort(newValue);
};

var roundToStep = function roundToStep(min, max, step, newPoint) {
  var stepPrecision = getPrecision(step);
  var roundedPoint = precisionRound((newPoint - min) / step * step + min, stepPrecision);
  return Math.max(Math.min(roundedPoint, max), min);
};

var calculatePointValue = function calculatePointValue(mouseX, containerRect, min, max, step) {
  var mousePosition = mouseX - containerRect.left;
  var possibleValueRange = max - min;
  var newPoint = mousePosition / containerRect.width * possibleValueRange + min;
  return roundToStep(min, max, step, newPoint);
};

var boundValueProp = function boundValueProp(min, max, value) {
  return map(value || [min, max], function (point) {
    var boundedPoint = Math.max(Math.min(point, max), min);

    if (boundedPoint !== point) {
      console.warn("<RangeSlider />: The value '".concat(point, "' falls outside the possible range (MIN: ").concat(min, ", MAX: ").concat(max, "). Please adjust min and max props accordingly."));
    }

    return boundedPoint;
  });
};

export var InternalRangeSlider = forwardRef(function (_ref, ref) {
  var className = _ref.className,
      id = _ref.id,
      _ref$min = _ref.min,
      min = _ref$min === void 0 ? 0 : _ref$min,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? 10 : _ref$max,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 1 : _ref$step,
      valueFromProps = _ref.value,
      defaultValueProp = _ref.defaultValue,
      onChange = _ref.onChange,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$readOnly = _ref.readOnly,
      readOnlyProp = _ref$readOnly === void 0 ? false : _ref$readOnly,
      ariaLabelledby = _ref['aria-labelledby'],
      ariaDescribedby = _ref['aria-describedby'];

  var _useTranslation = useTranslation('RangeSlider'),
      t = _useTranslation.t;

  var valuePropMin = valueFromProps === null || valueFromProps === void 0 ? void 0 : valueFromProps[0];
  var valuePropMax = valueFromProps === null || valueFromProps === void 0 ? void 0 : valueFromProps[1];
  var valueProp = useMemo(function () {
    if (valuePropMin === undefined || valuePropMax === undefined) {
      return undefined;
    }

    return [valuePropMin, valuePropMax];
  }, [valuePropMin, valuePropMax]);
  var unintentionalReadOnly = useReadOnlyWarn('RangeSlider', valueProp, onChange);
  var readOnly = readOnlyProp || unintentionalReadOnly;

  var _useState = useState(function () {
    var boundedValue = boundValueProp(min, max, valueProp || defaultValueProp);
    return sort(boundedValue);
  }),
      _useState2 = _slicedToArray(_useState, 2),
      valueState = _useState2[0],
      setValue = _useState2[1];

  var valueMin = valueState[0];
  var valueMax = valueState[1];
  var value = useMemo(function () {
    return [valueMin, valueMax];
  }, [valueMin, valueMax]);

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      containerRef = _useState4[0],
      setContainerRef = _useState4[1];

  var _useState5 = useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      focusedThumb = _useState6[0],
      setFocusedThumb = _useState6[1];

  var _useMeasuredElement = useMeasuredElement(containerRef),
      _useMeasuredElement2 = _slicedToArray(_useMeasuredElement, 2),
      containerRect = _useMeasuredElement2[0],
      refreshDomRect = _useMeasuredElement2[1];

  var _useMouseDragPosition = useMouseDragPosition(containerRef),
      mousePos = _useMouseDragPosition.mousePos,
      isMouseDown = _useMouseDragPosition.isMouseDown;

  var previousIsMouseDown = usePreviousValue(isMouseDown);
  var minThumbRef = useRef(null);
  var maxThumbRef = useRef(null);

  var _value = _slicedToArray(value, 2),
      minValue = _value[0],
      maxValue = _value[1];

  var minPos = (minValue - min) / (max - min) * containerRect.width;
  var maxPos = (maxValue - min) / (max - min) * containerRect.width;
  var fillWidth = maxPos - minPos;
  var roundSliderValue = partial(roundToStep, min, max, step);
  var focusChangedPoint = useCallback(function (newValue, newPoint) {
    var indexToFocus = indexOf(newValue, newPoint);
    var thumbRefs = [minThumbRef, maxThumbRef];
    var refToFocus = thumbRefs[indexToFocus];
    setFocusedThumb(indexToFocus);
    refToFocus.current && refToFocus.current.focus();
  }, []);

  var incrementPoint = function incrementPoint(point) {
    var stepMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return point + step * stepMultiplier;
  };

  var decrementPoint = function decrementPoint(point) {
    var stepMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return point - step * stepMultiplier;
  };

  var handleKeyboardNav = function handleKeyboardNav(e) {
    if (!disabled && !readOnly) {
      if (startsWith(e.key, 'Arrow') && focusedThumb !== undefined) {
        e.preventDefault();
        var unfocusedThumb = focusedThumb === 0 ? 1 : 0;
        var mutationFn = e.key === 'ArrowUp' || e.key === 'ArrowRight' ? incrementPoint : decrementPoint;
        var newPoint = roundSliderValue(mutationFn(value[focusedThumb], e.shiftKey ? 10 : 1));
        var newValue = sort([newPoint, value[unfocusedThumb]]);
        focusChangedPoint(newValue, newPoint);
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
      }
    }
  };

  var focusMinThumb = function focusMinThumb() {
    if (!disabled && !readOnly) {
      setFocusedThumb(0);
    }
  };

  var focusMaxThumb = function focusMaxThumb() {
    if (!disabled && !readOnly) {
      setFocusedThumb(1);
    }
  };

  var handleBlur = function handleBlur() {
    setFocusedThumb(undefined);
  };

  var handleMouseEvent = useCallback(function (maintainFocus) {
    if (!disabled && !readOnly && mousePos.x) {
      var newPoint = calculatePointValue(mousePos.x, containerRect, min, max, step);
      var newValue = createNewValue(value, newPoint, maintainFocus ? focusedThumb : undefined);
      focusChangedPoint(newValue, newPoint);

      if (!isEqual(value, newValue)) {
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
      }
    }
  }, [containerRect, disabled, focusChangedPoint, focusedThumb, max, min, mousePos.x, onChange, readOnly, step, value]);
  var handleMouseDown = useMemo(function () {
    return partial(handleMouseEvent, false);
  }, [handleMouseEvent]);
  var handleMouseDrag = useMemo(function () {
    return partial(handleMouseEvent, true);
  }, [handleMouseEvent]);
  useEffect(function () {
    if (isMouseDown) {
      refreshDomRect();
    }
  }, [isMouseDown, refreshDomRect]);
  useEffect(function () {
    if (isMouseDown) {
      handleMouseDown();
    }
  }, [isMouseDown, handleMouseDown, containerRect]);
  useEffect(function () {
    if (isMouseDown && previousIsMouseDown) {
      handleMouseDrag();
    }
  }, [isMouseDown, previousIsMouseDown, handleMouseDrag, mousePos]);
  var previousValueProp = usePreviousValue(valueProp);
  useEffect(function () {
    var boundedValueProp = boundValueProp(min, max, valueProp);

    if (valueProp && !isEqual(value, boundedValueProp) && !isEqual(valueProp, previousValueProp)) {
      setValue(sort(boundedValueProp));
    }
  }, [valueProp, previousValueProp, value, min, max]);
  useEffect(function () {
    var boundedValueProp = boundValueProp(min, max, valueProp);

    if (valueProp && !isEqual(valueProp, boundedValueProp)) {
      onChange === null || onChange === void 0 ? void 0 : onChange(sort(boundedValueProp));
    }
  }, [valueProp, onChange, min, max]);
  return React.createElement("div", {
    "data-testid": "range-slider-wrapper",
    onTouchEnd: handleBlur,
    className: className,
    id: id,
    ref: setContainerRef
  }, React.createElement(SliderTrack, {
    ref: ref,
    "aria-labelledby": ariaLabelledby,
    "aria-describedby": ariaDescribedby
  }, React.createElement(SliderFill, {
    fillStart: minPos,
    fillWidth: fillWidth,
    disabled: disabled
  }), React.createElement(ThumbLabel, {
    position: minPos,
    focus: focusedThumb === 0,
    disabled: disabled
  }, minValue), React.createElement(ThumbLabel, {
    position: maxPos,
    focus: focusedThumb === 1,
    disabled: disabled
  }, maxValue), React.createElement(Thumb, {
    position: minPos,
    tabIndex: disabled ? '-1' : '0',
    onFocus: focusMinThumb,
    onBlur: handleBlur,
    onKeyDown: handleKeyboardNav,
    ref: minThumbRef,
    disabled: disabled,
    "aria-label": t('Minimum Value'),
    role: "slider",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-disabled": disabled,
    "aria-valuenow": value[0]
  }), React.createElement(Thumb, {
    position: maxPos,
    tabIndex: disabled ? '-1' : '0',
    onFocus: focusMaxThumb,
    onBlur: handleBlur,
    onKeyDown: handleKeyboardNav,
    ref: maxThumbRef,
    disabled: disabled,
    "aria-label": t('Maximum Value'),
    role: "slider",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-disabled": disabled,
    "aria-valuenow": value[1]
  })));
});
InternalRangeSlider.displayName = 'InternalRangeSlider';
export var RangeSlider = styled(InternalRangeSlider).attrs(function (_ref2) {
  var _ref2$fontSize = _ref2.fontSize,
      fontSize = _ref2$fontSize === void 0 ? 'small' : _ref2$fontSize,
      _ref2$lineHeight = _ref2.lineHeight,
      lineHeight = _ref2$lineHeight === void 0 ? 'xsmall' : _ref2$lineHeight;
  return {
    fontSize: fontSize,
    lineHeight: lineHeight
  };
}).withConfig({
  displayName: "RangeSlider",
  componentId: "sc-1w8bpgp-0"
})(["", " ", " ", " padding:1.5rem 0 0.5rem;touch-action:none;user-select:none;"], reset, space, typography);
var SliderTrack = styled.div.withConfig({
  displayName: "RangeSlider__SliderTrack",
  componentId: "sc-1w8bpgp-1"
})(["background:", ";border-radius:2px;height:4px;position:relative;"], function (_ref3) {
  var theme = _ref3.theme;
  return theme.colors.ui2;
});
var ThumbLabel = styled.div.withConfig({
  displayName: "RangeSlider__ThumbLabel",
  componentId: "sc-1w8bpgp-2"
})(["background:", ";border-radius:1rem;color:", ";padding:0 0.5rem;position:absolute;text-align:center;top:-24px;transform:translateX(", ") translateX(-50%);user-select:none;z-index:", ";"], function (_ref4) {
  var theme = _ref4.theme,
      focus = _ref4.focus;
  return focus && theme.colors.keyAccent;
}, function (_ref5) {
  var colors = _ref5.theme.colors,
      disabled = _ref5.disabled;
  return disabled ? colors.neutral : colors.key;
}, function (_ref6) {
  var _ref6$position = _ref6.position,
      position = _ref6$position === void 0 ? 0 : _ref6$position;
  return "".concat(position, "px");
}, function (_ref7) {
  var focus = _ref7.focus;
  return focus ? 1 : 0;
});
var Thumb = styled.div.withConfig({
  displayName: "RangeSlider__Thumb",
  componentId: "sc-1w8bpgp-3"
})(["background:", ";border:3px solid ", ";border-radius:100%;cursor:pointer;height:16px;margin-left:-8px;position:absolute;top:-6px;transform:translateX(", ");width:16px;&:focus{border-width:", ";outline:none;z-index:1;}"], function (_ref8) {
  var theme = _ref8.theme;
  return theme.colors.field;
}, function (_ref9) {
  var colors = _ref9.theme.colors,
      disabled = _ref9.disabled;
  return disabled ? colors.neutral : colors.key;
}, function (_ref10) {
  var _ref10$position = _ref10.position,
      position = _ref10$position === void 0 ? 0 : _ref10$position;
  return "".concat(position, "px");
}, function (_ref11) {
  var disabled = _ref11.disabled;
  return disabled ? '3px' : '5px';
});
var SliderFill = styled.div.withConfig({
  displayName: "RangeSlider__SliderFill",
  componentId: "sc-1w8bpgp-4"
})(["background:", ";height:100%;left:", "px;position:absolute;width:", "px;"], function (_ref12) {
  var colors = _ref12.theme.colors,
      disabled = _ref12.disabled;
  return disabled ? colors.neutral : colors.key;
}, function (_ref13) {
  var fillStart = _ref13.fillStart;
  return fillStart;
}, function (_ref14) {
  var fillWidth = _ref14.fillWidth;
  return fillWidth;
});
//# sourceMappingURL=RangeSlider.js.map
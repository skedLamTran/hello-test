import findIndex from 'lodash/findIndex';
import React, { useContext, useEffect, useMemo, useRef } from 'react';
import { getWindowedListBoundaries } from '../../../../utils/getWindowedListBoundaries';
import { ComboboxContext, ComboboxMultiContext } from '../../Combobox';
export var optionHeight = 28;
export function useShouldWindowOptions(flatOptions, propsWindowedOptions) {
  return useMemo(function () {
    if (!flatOptions) return false;
    if (propsWindowedOptions === false) return false;
    if (flatOptions.length < 100 && !propsWindowedOptions) return false;
    return true;
  }, [flatOptions, propsWindowedOptions]);
}
export function useWindowedOptions(windowing, flatOptions, navigationOptions, isMulti) {
  var context = useContext(ComboboxContext);
  var contextMulti = useContext(ComboboxMultiContext);
  var contextToUse = isMulti ? contextMulti : context;
  var navigationOption = contextToUse.data.navigationOption,
      listClientRect = contextToUse.listClientRect,
      listScrollPosition = contextToUse.listScrollPosition,
      isScrollingRef = contextToUse.isScrollingRef,
      optionsRef = contextToUse.optionsRef;
  useEffect(function () {
    if (navigationOptions !== null && navigationOptions !== void 0 && navigationOptions.length && optionsRef) {
      optionsRef.current = navigationOptions;
    }
  }, [navigationOptions, optionsRef]);
  var containerHeight = listClientRect && listClientRect.height;

  var _useMemo = useMemo(function () {
    return getWindowedListBoundaries({
      enabled: windowing,
      height: containerHeight,
      itemCount: flatOptions ? flatOptions.length : 0,
      itemHeight: optionHeight,
      scrollPosition: listScrollPosition
    });
  }, [flatOptions, containerHeight, listScrollPosition, windowing]),
      start = _useMemo.start,
      end = _useMemo.end;

  var previouslyWindowedRef = useRef();

  if (windowing && !previouslyWindowedRef.current) {
    if (navigationOption) {
      var selectedIndex = findIndex(flatOptions, ['value', navigationOption.value]);

      if (selectedIndex > -1) {
        start = selectedIndex;
        end = selectedIndex;
      }
    }
  }

  previouslyWindowedRef.current = windowing;
  var scrollToFirst = false;
  var scrollToLast = false;

  if (flatOptions !== null && flatOptions !== void 0 && flatOptions.length && navigationOptions !== null && navigationOptions !== void 0 && navigationOptions.length && navigationOption) {
    scrollToFirst = !(isScrollingRef !== null && isScrollingRef !== void 0 && isScrollingRef.current) && start > 0 && navigationOption.value === navigationOptions[0].value;
    scrollToLast = end < flatOptions.length - 1 && navigationOption.value === navigationOptions[navigationOptions.length - 1].value;
  }

  var afterLength = flatOptions ? flatOptions.length - 1 - end : 0;
  return {
    after: afterLength > 0 ? React.createElement("li", {
      style: {
        height: "".concat(afterLength * optionHeight, "px")
      }
    }) : null,
    before: start > 0 ? React.createElement("li", {
      style: {
        height: "".concat(start * optionHeight, "px")
      }
    }) : null,
    end: end,
    scrollToFirst: scrollToFirst,
    scrollToLast: scrollToLast,
    start: start
  };
}
//# sourceMappingURL=useWindowedOptions.js.map
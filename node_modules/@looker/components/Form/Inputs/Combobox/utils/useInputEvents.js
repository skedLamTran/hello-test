import { useRef, useContext, useCallback } from 'react';
import { targetIsButton, useMouseDownClick, useWrapEvent } from '../../../../utils';
import { ComboboxActionType, ComboboxState } from './state';
import { useBlur } from './useBlur';
import { useKeyDown } from './useKeyDown';
export function useInputEvents(_ref, context) {
  var disabled = _ref.disabled,
      _ref$selectOnClick = _ref.selectOnClick,
      selectOnClick = _ref$selectOnClick === void 0 ? false : _ref$selectOnClick,
      _ref$inputReadOnly = _ref.inputReadOnly,
      inputReadOnly = _ref$inputReadOnly === void 0 ? false : _ref$inputReadOnly,
      onClick = _ref.onClick,
      onMouseDown = _ref.onMouseDown,
      onKeyDown = _ref.onKeyDown,
      onBlur = _ref.onBlur,
      onFocus = _ref.onFocus;

  var _useContext = useContext(context),
      lastActionType = _useContext.data.lastActionType,
      inputElement = _useContext.inputElement,
      openOnFocus = _useContext.openOnFocus,
      openOnClick = _useContext.openOnClick,
      persistSelectionPropRef = _useContext.persistSelectionPropRef,
      state = _useContext.state,
      transition = _useContext.transition;

  var selectOnClickRef = useRef(false);
  var handleKeyDown = useKeyDown();
  var handleBlur = useBlur(context);

  function handleFocus(e) {
    if (inputReadOnly) {
      var input = e.currentTarget;
      input.selectionStart = input.selectionEnd;
    } else if (selectOnClick) {
      selectOnClickRef.current = true;
    }

    if (openOnFocus && lastActionType !== ComboboxActionType.SELECT_WITH_CLICK && lastActionType !== ComboboxActionType.NAVIGATE) {
      transition && transition(ComboboxActionType.FOCUS, {
        persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
      });
    }
  }

  var selectText = useCallback(function () {
    if (selectOnClickRef.current) {
      selectOnClickRef.current = false;
      inputElement && inputElement.select();
    }
  }, [inputElement]);
  var handleMouseDownClick = useCallback(function (e) {
    if (disabled) return;

    if (targetIsButton(e)) {
      return;
    }

    if (state === ComboboxState.IDLE) {
      if (openOnClick) {
        transition && transition(ComboboxActionType.FOCUS, {
          persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
        });
      }
    } else {
      transition && transition(ComboboxActionType.ESCAPE);
    }

    if (e.type === 'click') {
      selectText();
    }
  }, [disabled, openOnClick, persistSelectionPropRef, state, selectText, transition]);
  var handleMouseUp = useCallback(function (e) {
    if (e.target === inputElement) {
      selectText();
    }
  }, [inputElement, selectText]);

  var _useMouseDownClick = useMouseDownClick(handleMouseDownClick, handleMouseUp),
      handleMouseDown = _useMouseDownClick.onMouseDown,
      handleClick = _useMouseDownClick.onClick;

  var wrappedOnBlur = useWrapEvent(handleBlur, onBlur);
  var wrappedOnClick = useWrapEvent(handleClick, onClick);
  var wrappedOnFocus = useWrapEvent(handleFocus, onFocus);
  var wrappedOnMouseDown = useWrapEvent(handleMouseDown, onMouseDown);
  var wrappedOnKeyDown = useWrapEvent(handleKeyDown, onKeyDown);
  return {
    onBlur: wrappedOnBlur,
    onClick: wrappedOnClick,
    onFocus: wrappedOnFocus,
    onKeyDown: wrappedOnKeyDown,
    onMouseDown: wrappedOnMouseDown
  };
}
//# sourceMappingURL=useInputEvents.js.map
import "core-js/modules/es.object.define-property.js";
import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.array.filter.js";
import "core-js/modules/es.object.get-own-property-descriptor.js";
import "core-js/modules/es.array.for-each.js";
import "core-js/modules/web.dom-collections.for-each.js";
import "core-js/modules/es.object.get-own-property-descriptors.js";
import "core-js/modules/es.object.define-properties.js";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { useEffect, useRef } from 'react';
import styled from 'styled-components';
import { useMouseDragPosition, usePreviousValue } from '../../../../utils';
import { simpleHsvToHex } from '../utils';
import { Handle2d } from '../Handle';

var LightSaturationPreviewLayout = function LightSaturationPreviewLayout(_ref) {
  var _previewRef$current, _previewRef$current2;

  var className = _ref.className,
      hsv = _ref.hsv,
      setHsv = _ref.setHsv,
      previewWidth = _ref.width;
  var previewHeight = previewWidth * 0.75;
  var handleX = hsv.s * previewWidth;
  var handleY = previewHeight - hsv.v * previewHeight;
  var previewRef = useRef(null);
  var previewLeft = ((_previewRef$current = previewRef.current) === null || _previewRef$current === void 0 ? void 0 : _previewRef$current.getBoundingClientRect().left) || 0;
  var previewTop = ((_previewRef$current2 = previewRef.current) === null || _previewRef$current2 === void 0 ? void 0 : _previewRef$current2.getBoundingClientRect().top) || 0;

  var handleMouseDown = function handleMouseDown(event) {
    var clickEventX = event.clientX;
    var clickEventY = event.clientY;
    var newSaturation = (clickEventX - previewLeft) / previewWidth;
    var newValue = (previewHeight - (clickEventY - previewTop)) / previewHeight;
    setHsv(_objectSpread(_objectSpread({}, hsv), {}, {
      s: newSaturation,
      v: newValue
    }));
  };

  var _useMouseDragPosition = useMouseDragPosition(previewRef.current),
      isMouseDown = _useMouseDragPosition.isMouseDown,
      mousePos = _useMouseDragPosition.mousePos;

  var previousIsMouseDown = usePreviousValue(isMouseDown);

  var handleHandleDrag = function handleHandleDrag() {
    var newSaturation = (mousePos.x - previewLeft) / previewWidth;

    if (newSaturation > 1) {
      newSaturation = 1;
    } else if (newSaturation < 0) {
      newSaturation = 0;
    }

    var newValue = (previewHeight - (mousePos.y - previewTop)) / previewHeight;

    if (newValue > 1) {
      newValue = 1;
    } else if (newValue < 0) {
      newValue = 0;
    }

    setHsv(_objectSpread(_objectSpread({}, hsv), {}, {
      s: newSaturation,
      v: newValue
    }));
  };

  useEffect(function () {
    if (isMouseDown && previousIsMouseDown) {
      handleHandleDrag();
    }
  }, [mousePos]);
  var backgroundColor = simpleHsvToHex({
    h: hsv.h,
    s: 1,
    v: 1
  });
  var color = simpleHsvToHex(_objectSpread({}, hsv));
  return React.createElement(LightSaturationPreviewContainer, {
    backgroundColor: backgroundColor,
    className: className,
    isMouseDown: isMouseDown,
    onMouseDown: handleMouseDown,
    height: previewHeight,
    ref: previewRef,
    width: previewWidth,
    "data-testid": "light-saturation-preview"
  }, React.createElement(Handle2d, {
    color: color,
    isMouseDown: isMouseDown,
    x: handleX,
    y: handleY
  }));
};

var LightSaturationPreviewContainer = styled.div.attrs(function (_ref2) {
  var backgroundColor = _ref2.backgroundColor;
  return {
    style: {
      backgroundColor: backgroundColor
    }
  };
}).withConfig({
  displayName: "LightSaturationPreview__LightSaturationPreviewContainer",
  componentId: "sc-crmpxu-0"
})(["background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0));border-radius:", ";cursor:", ";height:", "px;width:", "px;"], function (_ref3) {
  var theme = _ref3.theme;
  return theme.radii.medium;
}, function (_ref4) {
  var isMouseDown = _ref4.isMouseDown;
  return isMouseDown ? 'grabbing' : 'default';
}, function (_ref5) {
  var height = _ref5.height;
  return height;
}, function (_ref6) {
  var width = _ref6.width;
  return width;
});
export var LightSaturationPreview = styled(LightSaturationPreviewLayout).withConfig({
  displayName: "LightSaturationPreview",
  componentId: "sc-crmpxu-1"
})([""]);
//# sourceMappingURL=LightSaturationPreview.js.map
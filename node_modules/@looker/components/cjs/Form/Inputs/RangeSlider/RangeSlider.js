"use strict";

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RangeSlider = exports.InternalRangeSlider = void 0;

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.array.map.js");

var _reactI18next = require("react-i18next");

var _react = _interopRequireWildcard(require("react"));

var _designTokens = require("@looker/design-tokens");

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _sortBy = _interopRequireDefault(require("lodash/sortBy"));

var _indexOf = _interopRequireDefault(require("lodash/indexOf"));

var _startsWith = _interopRequireDefault(require("lodash/startsWith"));

var _partial = _interopRequireDefault(require("lodash/partial"));

var _map = _interopRequireDefault(require("lodash/map"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _utils = require("../../../utils");

var _precisionUtils = require("./precisionUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const sort = arr => arr.sort((a, b) => a - b);

const findClosestIndex = (value, newPoint) => {
  const closestIndex = (0, _sortBy.default)(value.map((p, i) => ({
    distance: Math.abs(p - newPoint),
    index: i
  })), 'distance')[0].index;
  return closestIndex;
};

const createNewValue = (value, newPoint, focusedIndex) => {
  const indexToReplace = focusedIndex === undefined ? findClosestIndex(value, newPoint) : focusedIndex;
  const newValue = Object.assign([], value, {
    [indexToReplace]: newPoint
  });
  return sort(newValue);
};

const roundToStep = (min, max, step, newPoint) => {
  const stepPrecision = (0, _precisionUtils.getPrecision)(step);
  const roundedPoint = (0, _precisionUtils.precisionRound)((newPoint - min) / step * step + min, stepPrecision);
  return Math.max(Math.min(roundedPoint, max), min);
};

const calculatePointValue = (mouseX, containerRect, min, max, step) => {
  const mousePosition = mouseX - containerRect.left;
  const possibleValueRange = max - min;
  const newPoint = mousePosition / containerRect.width * possibleValueRange + min;
  return roundToStep(min, max, step, newPoint);
};

const boundValueProp = (min, max, value) => {
  return (0, _map.default)(value || [min, max], point => {
    const boundedPoint = Math.max(Math.min(point, max), min);

    if (boundedPoint !== point) {
      console.warn(`<RangeSlider />: The value '${point}' falls outside the possible range (MIN: ${min}, MAX: ${max}). Please adjust min and max props accordingly.`);
    }

    return boundedPoint;
  });
};

const InternalRangeSlider = (0, _react.forwardRef)(({
  className,
  id,
  min = 0,
  max = 10,
  step = 1,
  value: valueFromProps,
  defaultValue: defaultValueProp,
  onChange,
  disabled = false,
  readOnly: readOnlyProp = false,
  'aria-labelledby': ariaLabelledby,
  'aria-describedby': ariaDescribedby
}, ref) => {
  const _useTranslation = (0, _reactI18next.useTranslation)('RangeSlider'),
        t = _useTranslation.t;

  const valuePropMin = valueFromProps === null || valueFromProps === void 0 ? void 0 : valueFromProps[0];
  const valuePropMax = valueFromProps === null || valueFromProps === void 0 ? void 0 : valueFromProps[1];
  const valueProp = (0, _react.useMemo)(() => {
    if (valuePropMin === undefined || valuePropMax === undefined) {
      return undefined;
    }

    return [valuePropMin, valuePropMax];
  }, [valuePropMin, valuePropMax]);
  const unintentionalReadOnly = (0, _utils.useReadOnlyWarn)('RangeSlider', valueProp, onChange);
  const readOnly = readOnlyProp || unintentionalReadOnly;

  const _useState = (0, _react.useState)(() => {
    const boundedValue = boundValueProp(min, max, valueProp || defaultValueProp);
    return sort(boundedValue);
  }),
        _useState2 = _slicedToArray(_useState, 2),
        valueState = _useState2[0],
        setValue = _useState2[1];

  const valueMin = valueState[0];
  const valueMax = valueState[1];
  const value = (0, _react.useMemo)(() => {
    return [valueMin, valueMax];
  }, [valueMin, valueMax]);

  const _useState3 = (0, _react.useState)(null),
        _useState4 = _slicedToArray(_useState3, 2),
        containerRef = _useState4[0],
        setContainerRef = _useState4[1];

  const _useState5 = (0, _react.useState)(),
        _useState6 = _slicedToArray(_useState5, 2),
        focusedThumb = _useState6[0],
        setFocusedThumb = _useState6[1];

  const _useMeasuredElement = (0, _utils.useMeasuredElement)(containerRef),
        _useMeasuredElement2 = _slicedToArray(_useMeasuredElement, 2),
        containerRect = _useMeasuredElement2[0],
        refreshDomRect = _useMeasuredElement2[1];

  const _useMouseDragPosition = (0, _utils.useMouseDragPosition)(containerRef),
        mousePos = _useMouseDragPosition.mousePos,
        isMouseDown = _useMouseDragPosition.isMouseDown;

  const previousIsMouseDown = (0, _utils.usePreviousValue)(isMouseDown);
  const minThumbRef = (0, _react.useRef)(null);
  const maxThumbRef = (0, _react.useRef)(null);

  const _value = _slicedToArray(value, 2),
        minValue = _value[0],
        maxValue = _value[1];

  const minPos = (minValue - min) / (max - min) * containerRect.width;
  const maxPos = (maxValue - min) / (max - min) * containerRect.width;
  const fillWidth = maxPos - minPos;
  const roundSliderValue = (0, _partial.default)(roundToStep, min, max, step);
  const focusChangedPoint = (0, _react.useCallback)((newValue, newPoint) => {
    const indexToFocus = (0, _indexOf.default)(newValue, newPoint);
    const thumbRefs = [minThumbRef, maxThumbRef];
    const refToFocus = thumbRefs[indexToFocus];
    setFocusedThumb(indexToFocus);
    refToFocus.current && refToFocus.current.focus();
  }, []);

  const incrementPoint = (point, stepMultiplier = 1) => point + step * stepMultiplier;

  const decrementPoint = (point, stepMultiplier = 1) => point - step * stepMultiplier;

  const handleKeyboardNav = e => {
    if (!disabled && !readOnly) {
      if ((0, _startsWith.default)(e.key, 'Arrow') && focusedThumb !== undefined) {
        e.preventDefault();
        const unfocusedThumb = focusedThumb === 0 ? 1 : 0;
        const mutationFn = e.key === 'ArrowUp' || e.key === 'ArrowRight' ? incrementPoint : decrementPoint;
        const newPoint = roundSliderValue(mutationFn(value[focusedThumb], e.shiftKey ? 10 : 1));
        const newValue = sort([newPoint, value[unfocusedThumb]]);
        focusChangedPoint(newValue, newPoint);
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
      }
    }
  };

  const focusMinThumb = () => {
    if (!disabled && !readOnly) {
      setFocusedThumb(0);
    }
  };

  const focusMaxThumb = () => {
    if (!disabled && !readOnly) {
      setFocusedThumb(1);
    }
  };

  const handleBlur = () => {
    setFocusedThumb(undefined);
  };

  const handleMouseEvent = (0, _react.useCallback)(maintainFocus => {
    if (!disabled && !readOnly && mousePos.x) {
      const newPoint = calculatePointValue(mousePos.x, containerRect, min, max, step);
      const newValue = createNewValue(value, newPoint, maintainFocus ? focusedThumb : undefined);
      focusChangedPoint(newValue, newPoint);

      if (!(0, _isEqual.default)(value, newValue)) {
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
      }
    }
  }, [containerRect, disabled, focusChangedPoint, focusedThumb, max, min, mousePos.x, onChange, readOnly, step, value]);
  const handleMouseDown = (0, _react.useMemo)(() => (0, _partial.default)(handleMouseEvent, false), [handleMouseEvent]);
  const handleMouseDrag = (0, _react.useMemo)(() => (0, _partial.default)(handleMouseEvent, true), [handleMouseEvent]);
  (0, _react.useEffect)(() => {
    if (isMouseDown) {
      refreshDomRect();
    }
  }, [isMouseDown, refreshDomRect]);
  (0, _react.useEffect)(() => {
    if (isMouseDown) {
      handleMouseDown();
    }
  }, [isMouseDown, handleMouseDown, containerRect]);
  (0, _react.useEffect)(() => {
    if (isMouseDown && previousIsMouseDown) {
      handleMouseDrag();
    }
  }, [isMouseDown, previousIsMouseDown, handleMouseDrag, mousePos]);
  const previousValueProp = (0, _utils.usePreviousValue)(valueProp);
  (0, _react.useEffect)(() => {
    const boundedValueProp = boundValueProp(min, max, valueProp);

    if (valueProp && !(0, _isEqual.default)(value, boundedValueProp) && !(0, _isEqual.default)(valueProp, previousValueProp)) {
      setValue(sort(boundedValueProp));
    }
  }, [valueProp, previousValueProp, value, min, max]);
  (0, _react.useEffect)(() => {
    const boundedValueProp = boundValueProp(min, max, valueProp);

    if (valueProp && !(0, _isEqual.default)(valueProp, boundedValueProp)) {
      onChange === null || onChange === void 0 ? void 0 : onChange(sort(boundedValueProp));
    }
  }, [valueProp, onChange, min, max]);
  return _react.default.createElement("div", {
    "data-testid": "range-slider-wrapper",
    onTouchEnd: handleBlur,
    className: className,
    id: id,
    ref: setContainerRef
  }, _react.default.createElement(SliderTrack, {
    ref: ref,
    "aria-labelledby": ariaLabelledby,
    "aria-describedby": ariaDescribedby
  }, _react.default.createElement(SliderFill, {
    fillStart: minPos,
    fillWidth: fillWidth,
    disabled: disabled
  }), _react.default.createElement(ThumbLabel, {
    position: minPos,
    focus: focusedThumb === 0,
    disabled: disabled
  }, minValue), _react.default.createElement(ThumbLabel, {
    position: maxPos,
    focus: focusedThumb === 1,
    disabled: disabled
  }, maxValue), _react.default.createElement(Thumb, {
    position: minPos,
    tabIndex: disabled ? '-1' : '0',
    onFocus: focusMinThumb,
    onBlur: handleBlur,
    onKeyDown: handleKeyboardNav,
    ref: minThumbRef,
    disabled: disabled,
    "aria-label": t('Minimum Value'),
    role: "slider",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-disabled": disabled,
    "aria-valuenow": value[0]
  }), _react.default.createElement(Thumb, {
    position: maxPos,
    tabIndex: disabled ? '-1' : '0',
    onFocus: focusMaxThumb,
    onBlur: handleBlur,
    onKeyDown: handleKeyboardNav,
    ref: maxThumbRef,
    disabled: disabled,
    "aria-label": t('Maximum Value'),
    role: "slider",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-disabled": disabled,
    "aria-valuenow": value[1]
  })));
});
exports.InternalRangeSlider = InternalRangeSlider;
InternalRangeSlider.displayName = 'InternalRangeSlider';
const RangeSlider = (0, _styledComponents.default)(InternalRangeSlider).attrs(({
  fontSize = 'small',
  lineHeight = 'xsmall'
}) => ({
  fontSize,
  lineHeight
})).withConfig({
  displayName: "RangeSlider",
  componentId: "sc-1w8bpgp-0"
})(["", " ", " ", " padding:1.5rem 0 0.5rem;touch-action:none;user-select:none;"], _designTokens.reset, _designTokens.space, _designTokens.typography);
exports.RangeSlider = RangeSlider;

const SliderTrack = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__SliderTrack",
  componentId: "sc-1w8bpgp-1"
})(["background:", ";border-radius:2px;height:4px;position:relative;"], ({
  theme
}) => theme.colors.ui2);

const ThumbLabel = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__ThumbLabel",
  componentId: "sc-1w8bpgp-2"
})(["background:", ";border-radius:1rem;color:", ";padding:0 0.5rem;position:absolute;text-align:center;top:-24px;transform:translateX(", ") translateX(-50%);user-select:none;z-index:", ";"], ({
  theme,
  focus
}) => focus && theme.colors.keyAccent, ({
  theme: {
    colors
  },
  disabled
}) => disabled ? colors.neutral : colors.key, ({
  position = 0
}) => `${position}px`, ({
  focus
}) => focus ? 1 : 0);

const Thumb = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__Thumb",
  componentId: "sc-1w8bpgp-3"
})(["background:", ";border:3px solid ", ";border-radius:100%;cursor:pointer;height:16px;margin-left:-8px;position:absolute;top:-6px;transform:translateX(", ");width:16px;&:focus{border-width:", ";outline:none;z-index:1;}"], ({
  theme
}) => theme.colors.field, ({
  theme: {
    colors
  },
  disabled
}) => disabled ? colors.neutral : colors.key, ({
  position = 0
}) => `${position}px`, ({
  disabled
}) => disabled ? '3px' : '5px');

const SliderFill = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__SliderFill",
  componentId: "sc-1w8bpgp-4"
})(["background:", ";height:100%;left:", "px;position:absolute;width:", "px;"], ({
  theme: {
    colors
  },
  disabled
}) => disabled ? colors.neutral : colors.key, ({
  fillStart
}) => fillStart, ({
  fillWidth
}) => fillWidth);
//# sourceMappingURL=RangeSlider.js.map
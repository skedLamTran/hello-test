"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useKeyDown = useKeyDown;

var _findIndex = _interopRequireDefault(require("lodash/findIndex"));

var _throttle = _interopRequireDefault(require("lodash/throttle"));

var _xorWith = _interopRequireDefault(require("lodash/xorWith"));

var _react = require("react");

var _ComboboxContext = require("../ComboboxContext");

var _state = require("./state");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function useKeyDown() {
  const context = (0, _react.useContext)(_ComboboxContext.ComboboxContext);
  const contextMulti = (0, _react.useContext)(_ComboboxContext.ComboboxMultiContext);
  const contextToUse = context.transition ? context : contextMulti;
  const data = contextToUse.data,
        onChange = contextToUse.onChange,
        optionsRef = contextToUse.optionsRef,
        state = contextToUse.state,
        transition = contextToUse.transition,
        autoCompletePropRef = contextToUse.autoCompletePropRef,
        persistSelectionPropRef = contextToUse.persistSelectionPropRef,
        inputReadOnlyPropRef = contextToUse.inputReadOnlyPropRef,
        closeOnSelectPropRef = contextToUse.closeOnSelectPropRef;
  const navigationOption = data.navigationOption;

  function checkOnChange() {
    if (onChange) {
      if (context.transition) {
        ;
        onChange(navigationOption);
      } else {
        const newOptions = (0, _xorWith.default)(data.options, navigationOption ? [navigationOption] : [], (o1, o2) => o1.value === o2.value);
        onChange(newOptions);
      }
    }
  }

  function selectOption() {
    checkOnChange();
    transition && transition(_state.ComboboxActionType.SELECT_WITH_KEYBOARD, {
      persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
    });

    if (closeOnSelectPropRef && closeOnSelectPropRef.current) {
      transition && transition(_state.ComboboxActionType.ESCAPE);
    }
  }

  return (0, _throttle.default)(function handleKeyDown(event) {
    event.persist();
    const options = optionsRef ? optionsRef.current : [];

    switch (event.key) {
      case 'ArrowDown':
        {
          event.preventDefault();

          if (state === _state.ComboboxState.IDLE) {
            transition && transition(_state.ComboboxActionType.NAVIGATE, {
              persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
            });
          } else {
            const index = navigationOption ? (0, _findIndex.default)(options, ['value', navigationOption.value]) : -1;
            const atBottom = index === options.length - 1;

            if (atBottom) {
              if (autoCompletePropRef && autoCompletePropRef.current) {
                transition && transition(_state.ComboboxActionType.NAVIGATE, {
                  option: undefined
                });
              } else {
                const firstOption = options[0];
                transition && transition(_state.ComboboxActionType.NAVIGATE, {
                  option: firstOption
                });
              }
            } else {
              const nextOption = options[(index + 1) % options.length];
              transition && transition(_state.ComboboxActionType.NAVIGATE, {
                option: nextOption
              });
            }
          }

          break;
        }

      case 'ArrowUp':
        {
          event.preventDefault();

          if (state === _state.ComboboxState.IDLE) {
            transition && transition(_state.ComboboxActionType.NAVIGATE, {
              persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
            });
          } else {
            const index = navigationOption ? (0, _findIndex.default)(options, ['value', navigationOption.value]) : -1;

            if (index === 0) {
              if (autoCompletePropRef && autoCompletePropRef.current) {
                transition && transition(_state.ComboboxActionType.NAVIGATE, {
                  option: undefined
                });
              } else {
                const lastOption = options[options.length - 1];
                transition && transition(_state.ComboboxActionType.NAVIGATE, {
                  option: lastOption
                });
              }
            } else if (index === -1) {
              const option = options[options.length - 1];
              transition && transition(_state.ComboboxActionType.NAVIGATE, {
                option
              });
            } else {
              const nextOption = options[(index - 1 + options.length) % options.length];
              transition && transition && transition(_state.ComboboxActionType.NAVIGATE, {
                option: nextOption
              });
            }
          }

          break;
        }

      case ' ':
      case 'Spacebar':
        {
          if (inputReadOnlyPropRef && inputReadOnlyPropRef.current && state === _state.ComboboxState.NAVIGATING && navigationOption !== undefined) {
            selectOption();
          }

          break;
        }

      case 'Enter':
        {
          if (state === _state.ComboboxState.NAVIGATING && navigationOption !== undefined) {
            event.preventDefault();
            selectOption();
          }

          break;
        }
    }
  }, 50);
}
//# sourceMappingURL=useKeyDown.js.map
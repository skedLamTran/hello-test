"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInputEvents = useInputEvents;

var _react = require("react");

var _utils = require("../../../../utils");

var _state = require("./state");

var _useBlur = require("./useBlur");

var _useKeyDown = require("./useKeyDown");

function useInputEvents({
  disabled,
  selectOnClick = false,
  inputReadOnly = false,
  onClick,
  onMouseDown,
  onKeyDown,
  onBlur,
  onFocus
}, context) {
  const _useContext = (0, _react.useContext)(context),
        lastActionType = _useContext.data.lastActionType,
        inputElement = _useContext.inputElement,
        openOnFocus = _useContext.openOnFocus,
        openOnClick = _useContext.openOnClick,
        persistSelectionPropRef = _useContext.persistSelectionPropRef,
        state = _useContext.state,
        transition = _useContext.transition;

  const selectOnClickRef = (0, _react.useRef)(false);
  const handleKeyDown = (0, _useKeyDown.useKeyDown)();
  const handleBlur = (0, _useBlur.useBlur)(context);

  function handleFocus(e) {
    if (inputReadOnly) {
      const input = e.currentTarget;
      input.selectionStart = input.selectionEnd;
    } else if (selectOnClick) {
      selectOnClickRef.current = true;
    }

    if (openOnFocus && lastActionType !== _state.ComboboxActionType.SELECT_WITH_CLICK && lastActionType !== _state.ComboboxActionType.NAVIGATE) {
      transition && transition(_state.ComboboxActionType.FOCUS, {
        persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
      });
    }
  }

  const selectText = (0, _react.useCallback)(() => {
    if (selectOnClickRef.current) {
      selectOnClickRef.current = false;
      inputElement && inputElement.select();
    }
  }, [inputElement]);
  const handleMouseDownClick = (0, _react.useCallback)(e => {
    if (disabled) return;

    if ((0, _utils.targetIsButton)(e)) {
      return;
    }

    if (state === _state.ComboboxState.IDLE) {
      if (openOnClick) {
        transition && transition(_state.ComboboxActionType.FOCUS, {
          persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
        });
      }
    } else {
      transition && transition(_state.ComboboxActionType.ESCAPE);
    }

    if (e.type === 'click') {
      selectText();
    }
  }, [disabled, openOnClick, persistSelectionPropRef, state, selectText, transition]);
  const handleMouseUp = (0, _react.useCallback)(e => {
    if (e.target === inputElement) {
      selectText();
    }
  }, [inputElement, selectText]);

  const _useMouseDownClick = (0, _utils.useMouseDownClick)(handleMouseDownClick, handleMouseUp),
        handleMouseDown = _useMouseDownClick.onMouseDown,
        handleClick = _useMouseDownClick.onClick;

  const wrappedOnBlur = (0, _utils.useWrapEvent)(handleBlur, onBlur);
  const wrappedOnClick = (0, _utils.useWrapEvent)(handleClick, onClick);
  const wrappedOnFocus = (0, _utils.useWrapEvent)(handleFocus, onFocus);
  const wrappedOnMouseDown = (0, _utils.useWrapEvent)(handleMouseDown, onMouseDown);
  const wrappedOnKeyDown = (0, _utils.useWrapEvent)(handleKeyDown, onKeyDown);
  return {
    onBlur: wrappedOnBlur,
    onClick: wrappedOnClick,
    onFocus: wrappedOnFocus,
    onKeyDown: wrappedOnKeyDown,
    onMouseDown: wrappedOnMouseDown
  };
}
//# sourceMappingURL=useInputEvents.js.map
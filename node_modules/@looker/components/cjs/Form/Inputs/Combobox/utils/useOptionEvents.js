"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useOptionEvents = useOptionEvents;

var _xorWith = _interopRequireDefault(require("lodash/xorWith"));

var _react = require("react");

var _utils = require("../../../../utils");

var _state = require("./state");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function useOptionEvents(props, context) {
  const label = props.label,
        value = props.value,
        onClick = props.onClick,
        onMouseEnter = props.onMouseEnter;

  const _useContext = (0, _react.useContext)(context),
        data = _useContext.data,
        onChange = _useContext.onChange,
        transition = _useContext.transition,
        closeOnSelectPropRef = _useContext.closeOnSelectPropRef,
        isScrollingRef = _useContext.isScrollingRef;

  const _ref = data,
        options = _ref.options;

  function handleClick() {
    const option = {
      label,
      value
    };

    if (onChange) {
      if (options) {
        ;
        onChange((0, _xorWith.default)(options, [option], (o1, o2) => o1.value === o2.value));
      } else {
        ;
        onChange(option);
      }
    }

    transition && transition(_state.ComboboxActionType.SELECT_WITH_CLICK, {
      option
    });

    if (closeOnSelectPropRef && closeOnSelectPropRef.current) {
      transition && transition(_state.ComboboxActionType.ESCAPE);
    }
  }

  const handleMouseEnter = () => {
    requestAnimationFrame(() => {
      if (isScrollingRef !== null && isScrollingRef !== void 0 && isScrollingRef.current) return;
      const option = {
        label,
        value
      };
      transition && transition(_state.ComboboxActionType.NAVIGATE, {
        option
      });
    });
  };

  return {
    onClick: (0, _utils.useWrapEvent)(handleClick, onClick),
    onMouseEnter: (0, _utils.useWrapEvent)(handleMouseEnter, onMouseEnter)
  };
}
//# sourceMappingURL=useOptionEvents.js.map
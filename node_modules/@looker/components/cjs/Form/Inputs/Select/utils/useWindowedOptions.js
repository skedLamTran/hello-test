"use strict";

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useShouldWindowOptions = useShouldWindowOptions;
exports.useWindowedOptions = useWindowedOptions;
exports.optionHeight = void 0;

var _findIndex = _interopRequireDefault(require("lodash/findIndex"));

var _react = _interopRequireWildcard(require("react"));

var _getWindowedListBoundaries = require("../../../../utils/getWindowedListBoundaries");

var _Combobox = require("../../Combobox");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const optionHeight = 28;
exports.optionHeight = optionHeight;

function useShouldWindowOptions(flatOptions, propsWindowedOptions) {
  return (0, _react.useMemo)(() => {
    if (!flatOptions) return false;
    if (propsWindowedOptions === false) return false;
    if (flatOptions.length < 100 && !propsWindowedOptions) return false;
    return true;
  }, [flatOptions, propsWindowedOptions]);
}

function useWindowedOptions(windowing, flatOptions, navigationOptions, isMulti) {
  const context = (0, _react.useContext)(_Combobox.ComboboxContext);
  const contextMulti = (0, _react.useContext)(_Combobox.ComboboxMultiContext);
  const contextToUse = isMulti ? contextMulti : context;
  const navigationOption = contextToUse.data.navigationOption,
        listClientRect = contextToUse.listClientRect,
        listScrollPosition = contextToUse.listScrollPosition,
        isScrollingRef = contextToUse.isScrollingRef,
        optionsRef = contextToUse.optionsRef;
  (0, _react.useEffect)(() => {
    if (navigationOptions !== null && navigationOptions !== void 0 && navigationOptions.length && optionsRef) {
      optionsRef.current = navigationOptions;
    }
  }, [navigationOptions, optionsRef]);
  const containerHeight = listClientRect && listClientRect.height;

  let _useMemo = (0, _react.useMemo)(() => (0, _getWindowedListBoundaries.getWindowedListBoundaries)({
    enabled: windowing,
    height: containerHeight,
    itemCount: flatOptions ? flatOptions.length : 0,
    itemHeight: optionHeight,
    scrollPosition: listScrollPosition
  }), [flatOptions, containerHeight, listScrollPosition, windowing]),
      start = _useMemo.start,
      end = _useMemo.end;

  const previouslyWindowedRef = (0, _react.useRef)();

  if (windowing && !previouslyWindowedRef.current) {
    if (navigationOption) {
      const selectedIndex = (0, _findIndex.default)(flatOptions, ['value', navigationOption.value]);

      if (selectedIndex > -1) {
        start = selectedIndex;
        end = selectedIndex;
      }
    }
  }

  previouslyWindowedRef.current = windowing;
  let scrollToFirst = false;
  let scrollToLast = false;

  if (flatOptions !== null && flatOptions !== void 0 && flatOptions.length && navigationOptions !== null && navigationOptions !== void 0 && navigationOptions.length && navigationOption) {
    scrollToFirst = !(isScrollingRef !== null && isScrollingRef !== void 0 && isScrollingRef.current) && start > 0 && navigationOption.value === navigationOptions[0].value;
    scrollToLast = end < flatOptions.length - 1 && navigationOption.value === navigationOptions[navigationOptions.length - 1].value;
  }

  const afterLength = flatOptions ? flatOptions.length - 1 - end : 0;
  return {
    after: afterLength > 0 ? _react.default.createElement("li", {
      style: {
        height: `${afterLength * optionHeight}px`
      }
    }) : null,
    before: start > 0 ? _react.default.createElement("li", {
      style: {
        height: `${start * optionHeight}px`
      }
    }) : null,
    end,
    scrollToFirst,
    scrollToLast,
    start
  };
}
//# sourceMappingURL=useWindowedOptions.js.map
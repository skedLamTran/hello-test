"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGlobalHotkeys = void 0;

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.set.js");

var _reactHotkeysHook = require("react-hotkeys-hook");

var _get = _interopRequireDefault(require("lodash/get"));

var _filter = _interopRequireDefault(require("lodash/filter"));

var _debounce = _interopRequireDefault(require("lodash/debounce"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const keyCommandCollection = {};

const doRectsIntersect = (r1, r2) => {
  return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
};

const calculateIntersectionPoint = (r1, r2) => {
  const y = Math.max(r2.top, r1.top);
  const x = Math.max(r1.left, r2.left);
  return {
    x,
    y
  };
};

const organizeKeyCommands = shortcut => {
  const commandGroup = [...(0, _get.default)(keyCommandCollection, shortcut, [])];
  commandGroup.sort((ev1, ev2) => {
    const rect1 = ev1.target.getBoundingClientRect();
    const rect2 = ev2.target.getBoundingClientRect();

    if (!doRectsIntersect(rect1, rect2)) {
      return 0;
    } else {
      const _calculateIntersectio = calculateIntersectionPoint(rect1, rect2),
            x = _calculateIntersectio.x,
            y = _calculateIntersectio.y;

      const stackedElements = document.elementsFromPoint(x, y);
      const idx1 = stackedElements.findIndex(el => el === ev1.target);
      const idx2 = stackedElements.findIndex(el => el === ev2.target);
      return idx1 > idx2 ? 1 : -1;
    }
  });
  return commandGroup;
};

const executeFirstKeyCommand = (0, _debounce.default)((e, cbStack) => {
  cbStack[0] && cbStack[0].cb(e);
}, 50);

const discardStaleCommands = keyCommand => {
  const commandSet = keyCommandCollection[keyCommand];
  keyCommandCollection[keyCommand] = new Set((0, _filter.default)([...commandSet], event => document.body.contains(event.target)));
};

const useGlobalHotkeys = (keyCommand, cb, containerRef) => {
  if (containerRef.current) {
    const newCommand = {
      cb,
      target: containerRef.current
    };
    const commandSet = (0, _get.default)(keyCommandCollection, keyCommand, new Set());
    commandSet.add(newCommand);
    keyCommandCollection[keyCommand] = commandSet;
  }

  const wrappedCb = (e, handler) => {
    discardStaleCommands(handler.shortcut);
    const orderedEventListeners = organizeKeyCommands(handler.shortcut);
    executeFirstKeyCommand(e, orderedEventListeners);
  };

  (0, _reactHotkeysHook.useHotkeys)(keyCommand, wrappedCb, {
    filter: () => {
      return true;
    }
  });
};

exports.useGlobalHotkeys = useGlobalHotkeys;
//# sourceMappingURL=useGlobalHotkeys.js.map
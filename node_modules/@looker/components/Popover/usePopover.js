import "core-js/modules/es.array.is-array.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.from.js";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React, { useEffect, useMemo, useState } from 'react';
import { Flex } from '../Layout';
import { Portal } from '../Portal';
import { DialogContext } from '../Dialog';
import { OverlaySurface } from '../Overlay/OverlaySurface';
import { useCallbackRef, useFocusTrap, usePopper, useScrollLock, useForkedRef, useID } from '../utils';
import { usePopoverToggle } from './usePopoverToggle';
import { useVerticalSpace } from './useVerticalSpace';

var useOpenWithoutElement = function useOpenWithoutElement(isOpen, element) {
  var _useState = useState(isOpen && element === null),
      _useState2 = _slicedToArray(_useState, 2),
      openWithoutElem = _useState2[0],
      setOpenWithoutElem = _useState2[1];

  useEffect(function () {
    if (element && openWithoutElem) {
      setOpenWithoutElem(false);
    }
  }, [openWithoutElem, element]);
  return openWithoutElem;
};

export var usePopover = function usePopover(_ref) {
  var ariaHaspopup = _ref['aria-haspopup'],
      canClose = _ref.canClose,
      content = _ref.content,
      disabled = _ref.disabled,
      _ref$pin = _ref.pin,
      pin = _ref$pin === void 0 ? false : _ref$pin,
      _ref$isOpen = _ref.isOpen,
      controlledIsOpen = _ref$isOpen === void 0 ? false : _ref$isOpen,
      onClose = _ref.onClose,
      _ref$placement = _ref.placement,
      propsPlacement = _ref$placement === void 0 ? 'bottom' : _ref$placement,
      controlledSetOpen = _ref.setOpen,
      triggerElement = _ref.triggerElement,
      _ref$triggerToggle = _ref.triggerToggle,
      triggerToggle = _ref$triggerToggle === void 0 ? true : _ref$triggerToggle,
      _ref$focusTrap = _ref.focusTrap,
      focusTrap = _ref$focusTrap === void 0 ? true : _ref$focusTrap,
      _ref$scrollLock = _ref.scrollLock,
      scrollLock = _ref$scrollLock === void 0 ? true : _ref$scrollLock,
      cancelClickOutside = _ref.cancelClickOutside,
      surface = _ref.surface,
      width = _ref.width,
      id = _ref.id;

  var _useScrollLock = useScrollLock({
    disabled: !scrollLock
  }),
      _useScrollLock2 = _slicedToArray(_useScrollLock, 2),
      scrollElement = _useScrollLock2[0],
      scrollRef = _useScrollLock2[1];

  var _useFocusTrap = useFocusTrap({
    disabled: !focusTrap
  }),
      _useFocusTrap2 = _slicedToArray(_useFocusTrap, 2),
      focusRef = _useFocusTrap2[1];

  var _useCallbackRef = useCallbackRef(),
      _useCallbackRef2 = _slicedToArray(_useCallbackRef, 2),
      newTriggerElement = _useCallbackRef2[0],
      callbackRef = _useCallbackRef2[1];

  var element = typeof triggerElement === 'undefined' ? newTriggerElement : triggerElement;

  var _usePopoverToggle = usePopoverToggle({
    canClose: canClose,
    cancelClickOutside: cancelClickOutside,
    isOpen: controlledIsOpen,
    setOpen: controlledSetOpen,
    triggerToggle: triggerToggle
  }, scrollElement, element),
      _usePopoverToggle2 = _slicedToArray(_usePopoverToggle, 2),
      isOpen = _usePopoverToggle2[0],
      setOpen = _usePopoverToggle2[1];

  var openWithoutElem = useOpenWithoutElement(isOpen, element);

  var handleOpen = function handleOpen(event) {
    if (!disabled) {
      setOpen(true);
    }

    event.stopPropagation();
    event.preventDefault();
  };

  var handleClose = function handleClose() {
    if (canClose && !canClose()) return;
    setOpen(false);
    onClose && onClose();
  };

  var usePopperProps = useMemo(function () {
    return {
      anchor: element,
      options: {
        modifiers: [{
          enabled: !pin,
          name: 'flip',
          options: {
            flipVariations: true,
            flipVariationsByContent: true
          }
        }, {
          enabled: true,
          name: 'eventListeners',
          options: {
            scroll: false
          }
        }],
        placement: propsPlacement
      }
    };
  }, [element, pin, propsPlacement]);

  var _usePopper = usePopper(usePopperProps),
      placement = _usePopper.placement,
      popperInstanceRef = _usePopper.popperInstanceRef,
      style = _usePopper.style,
      targetRef = _usePopper.targetRef;

  var verticalSpace = useVerticalSpace(element, pin, propsPlacement, isOpen, style);
  var ref = useForkedRef(targetRef, focusRef);

  var _useCallbackRef3 = useCallbackRef(),
      _useCallbackRef4 = _slicedToArray(_useCallbackRef3, 2),
      containerElement = _useCallbackRef4[0],
      contentContainerRef = _useCallbackRef4[1];

  var SurfaceComponent = surface || OverlaySurface;
  id = useID(id);
  var popover = content && !openWithoutElem && isOpen && !disabled && React.createElement(DialogContext.Provider, {
    value: {
      closeModal: handleClose,
      id: id
    }
  }, React.createElement(Portal, {
    ref: scrollRef
  }, React.createElement(SurfaceComponent, {
    "aria-labelledby": "".concat(id, "-heading"),
    "aria-modal": true,
    maxWidth: width,
    placement: placement,
    ref: ref,
    role: "dialog",
    style: style
  }, React.createElement(Flex, {
    alignItems: "flex-start",
    borderRadius: "inherit",
    flexDirection: "column",
    id: id,
    maxHeight: "calc(".concat(verticalSpace - 10, "px - 1rem)"),
    overflowY: "auto",
    ref: contentContainerRef
  }, content))));
  return {
    contentContainer: containerElement,
    domProps: {
      'aria-expanded': isOpen,
      'aria-haspopup': content && !disabled ? ariaHaspopup : false,
      onClick: handleOpen,
      ref: callbackRef
    },
    isOpen: isOpen,
    open: handleOpen,
    popover: popover,
    popperInstanceRef: popperInstanceRef,
    ref: callbackRef
  };
};
//# sourceMappingURL=usePopover.js.map
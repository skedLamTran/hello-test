{"version":3,"file":"react-hotkeys-hook.esm.js","sources":["../src/useIsHotkeyPressed.ts","../src/useHotkeys.ts"],"sourcesContent":["import hotkeys from \"hotkeys-js\";\n\nexport function useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}","import hotkeys, {HotkeysEvent, KeyHandler} from \"hotkeys-js\";\nimport React, {useCallback, useEffect, useRef} from \"react\";\n\ntype AvailableTags = 'INPUT' | 'TEXTAREA' | 'SELECT';\n\nexport type Options = {\n  filter?: typeof hotkeys.filter;\n  enableOnTags?: AvailableTags[];\n  splitKey?: string;\n  scope?: string;\n  keyup?: boolean;\n  keydown?: boolean;\n};\n\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: any[] | Options, deps?: any[]): React.MutableRefObject<T | null> {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n  const {enableOnTags, filter} = options || {};\n\n  const ref = useRef<T | null>(null);\n\n  const memoisedCallback = useCallback((keyboardEvent: KeyboardEvent, hotkeysEvent: HotkeysEvent) => {\n    if (ref.current === null || document.activeElement === ref.current) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, ...deps] : [ref]);\n\n  useEffect(() => {\n    if (options && (options as Options).enableOnTags) {\n      hotkeys.filter = ({target, srcElement}) => {\n        // @ts-ignore\n        const targetTagName = (target && target.tagName) || (srcElement && srcElement.tagName);\n\n        return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName as AvailableTags));\n      };\n    }\n\n    if (filter) hotkeys.filter = filter;\n\n    hotkeys(keys, (options as Options) || {}, memoisedCallback);\n\n    return () => hotkeys.unbind(keys, memoisedCallback);\n  }, [memoisedCallback, options, enableOnTags, filter, keys]);\n\n  return ref;\n}"],"names":["useIsHotkeyPressed","hotkeys","isPressed","useHotkeys","keys","callback","options","deps","Array","undefined","enableOnTags","filter","ref","useRef","memoisedCallback","useCallback","keyboardEvent","hotkeysEvent","current","document","activeElement","useEffect","target","srcElement","targetTagName","tagName","Boolean","includes","unbind"],"mappings":";;;SAEgBA;AACd,SAAOC,OAAO,CAACC,SAAf;AACD;;SCaeC,WAA8BC,MAAcC,UAAsBC,SAA2BC;AAC3G,MAAID,OAAO,YAAYE,KAAvB,EAA8B;AAC5BD,IAAAA,IAAI,GAAGD,OAAP;AACAA,IAAAA,OAAO,GAAGG,SAAV;AACD;;aAC8BH,OAAO,IAAI;MAAnCI,oBAAAA;MAAcC,cAAAA;;AAErB,MAAMC,GAAG,GAAGC,MAAM,CAAW,IAAX,CAAlB;AAEA,MAAMC,gBAAgB,GAAGC,WAAW,CAAC,UAACC,aAAD,EAA+BC,YAA/B;AACnC,QAAIL,GAAG,CAACM,OAAJ,KAAgB,IAAhB,IAAwBC,QAAQ,CAACC,aAAT,KAA2BR,GAAG,CAACM,OAA3D,EAAoE;AAClEb,MAAAA,QAAQ,CAACW,aAAD,EAAgBC,YAAhB,CAAR;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAPmC,EAOjCV,IAAI,IAAIK,GAAJ,SAAYL,IAAZ,IAAoB,CAACK,GAAD,CAPS,CAApC;AASAS,EAAAA,SAAS,CAAC;AACR,QAAIf,OAAO,IAAKA,OAAmB,CAACI,YAApC,EAAkD;AAChDT,MAAAA,OAAO,CAACU,MAAR,GAAiB;YAAEW,eAAAA;YAAQC,mBAAAA;AACzB;AACA,YAAMC,aAAa,GAAIF,MAAM,IAAIA,MAAM,CAACG,OAAlB,IAA+BF,UAAU,IAAIA,UAAU,CAACE,OAA9E;AAEA,eAAOC,OAAO,CAACF,aAAa,IAAId,YAAjB,IAAiCA,YAAY,CAACiB,QAAb,CAAsBH,aAAtB,CAAlC,CAAd;AACD,OALD;AAMD;;AAED,QAAIb,MAAJ,EAAYV,OAAO,CAACU,MAAR,GAAiBA,MAAjB;AAEZV,IAAAA,OAAO,CAACG,IAAD,EAAQE,OAAmB,IAAI,EAA/B,EAAmCQ,gBAAnC,CAAP;AAEA,WAAO;AAAA,aAAMb,OAAO,CAAC2B,MAAR,CAAexB,IAAf,EAAqBU,gBAArB,CAAN;AAAA,KAAP;AACD,GAfQ,EAeN,CAACA,gBAAD,EAAmBR,OAAnB,EAA4BI,YAA5B,EAA0CC,MAA1C,EAAkDP,IAAlD,CAfM,CAAT;AAiBA,SAAOQ,GAAP;AACD;;;;"}